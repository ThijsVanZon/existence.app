<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2015-2025</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
  <a href="{{ url_for('index') }}"><h1>Timeline</h1></a>
  <nav class="timeline" aria-label="enlightenment timeline">
    <div class="sub-decade-container" id="decade-2015">
      <span class="sub-decade" id="sub-decade-2015">2015</span>
    </div>
    <div class="main-decade-container" id="decade-2020">
      <span class="main-decade" id="main-decade-2020">ENLIGHTENMENT</span>
    </div>
    <div class="sub-decade-container" id="decade-2025">
      <span class="sub-decade" id="sub-decade-2025">2025</span>
    </div>
  </nav>

  <section class="scrape-toolbar" hidden>
    <p class="toolbar-hint">Run any sleeve with one shared filter setup. This keeps comparisons fair across sleeves and avoids repetitive toggling.</p>
    <p class="toolbar-hint" id="profile-hint">Active profile: MVP (Indeed + LinkedIn direct sources, NL focus).</p>
    <div class="toolbar-grid">
      <div class="toolbar-field">
        <label for="global-location">Location scope</label>
        <select id="global-location">
          <option value="nl_only">Netherlands focus</option>
          <option value="nl_eu">Netherlands + EU remote</option>
          <option value="global">Global</option>
        </select>
      </div>

      <div class="toolbar-field">
        <label>Results view</label>
        <p class="toolbar-static">10 per page. Use Next/Previous per sleeve to browse all results.</p>
      </div>

      <div class="toolbar-field toolbar-checks">
        <label class="control-inline">
          <input type="checkbox" id="global-strict" checked>
          Strict sleeve matching
        </label>
        <label class="control-inline">
          <input type="checkbox" id="global-cache" checked>
          Use cache (faster)
        </label>
        <label class="control-inline" id="global-failover-wrap">
          <input type="checkbox" id="global-failover">
          Auto failover sources
        </label>
      </div>
    </div>

    <div class="toolbar-field">
      <div class="source-title">Enabled Sources</div>
      <div id="global-sources" class="source-toggle-group"></div>
      <div id="source-note" class="toolbar-note"></div>
      <details id="unavailable-sources" class="unavailable-sources" hidden>
        <summary>Unavailable sources</summary>
        <div id="unavailable-source-list"></div>
      </details>
    </div>
  </section>

  <div class="sleeve-grid">
    <section class="sleeve-panel" id="panel-A">
      <h3>
        <span class="sleeve-header-name">Music Events & Festivals</span>
        <span class="sleeve-header-code">Career Sleeve A</span>
      </h3>
      <div class="terms-editor" data-sleeve="A">
        <label class="terms-label" for="terms-input-A">Search terms</label>
        <div id="terms-chips-A" class="terms-chip-list" aria-live="polite"></div>
        <input id="terms-input-A" class="terms-input" type="text" placeholder="Type term and press Enter">
        <div class="terms-actions">
          <button type="button" class="terms-reset-btn" onclick="resetSleeveTerms('A')">Reset terms</button>
        </div>
      </div>
      <button type="button" class="scrape-btn" data-sleeve="A" onclick="startScraping('A')">Scrape Career Sleeve A</button>
      <p id="status-A" aria-live="polite"></p>
      <div id="progress-A" class="progress-field" hidden></div>
      <div id="summary-A" class="sleeve-summary" hidden></div>
      <div id="error-A" class="error" style="display: none;"></div>
      <div id="results-A"></div>
      <div id="pager-A" class="results-pager" hidden></div>
    </section>

    <section class="sleeve-panel" id="panel-B">
      <h3>
        <span class="sleeve-header-name">Theme Parks & Destinations</span>
        <span class="sleeve-header-code">Career Sleeve B</span>
      </h3>
      <div class="terms-editor" data-sleeve="B">
        <label class="terms-label" for="terms-input-B">Search terms</label>
        <div id="terms-chips-B" class="terms-chip-list" aria-live="polite"></div>
        <input id="terms-input-B" class="terms-input" type="text" placeholder="Type term and press Enter">
        <div class="terms-actions">
          <button type="button" class="terms-reset-btn" onclick="resetSleeveTerms('B')">Reset terms</button>
        </div>
      </div>
      <button type="button" class="scrape-btn" data-sleeve="B" onclick="startScraping('B')">Scrape Career Sleeve B</button>
      <p id="status-B" aria-live="polite"></p>
      <div id="progress-B" class="progress-field" hidden></div>
      <div id="summary-B" class="sleeve-summary" hidden></div>
      <div id="error-B" class="error" style="display: none;"></div>
      <div id="results-B"></div>
      <div id="pager-B" class="results-pager" hidden></div>
    </section>

    <section class="sleeve-panel" id="panel-C">
      <h3>
        <span class="sleeve-header-name">Data Centers & Facilities</span>
        <span class="sleeve-header-code">Career Sleeve C</span>
      </h3>
      <div class="terms-editor" data-sleeve="C">
        <label class="terms-label" for="terms-input-C">Search terms</label>
        <div id="terms-chips-C" class="terms-chip-list" aria-live="polite"></div>
        <input id="terms-input-C" class="terms-input" type="text" placeholder="Type term and press Enter">
        <div class="terms-actions">
          <button type="button" class="terms-reset-btn" onclick="resetSleeveTerms('C')">Reset terms</button>
        </div>
      </div>
      <button type="button" class="scrape-btn" data-sleeve="C" onclick="startScraping('C')">Scrape Career Sleeve C</button>
      <p id="status-C" aria-live="polite"></p>
      <div id="progress-C" class="progress-field" hidden></div>
      <div id="summary-C" class="sleeve-summary" hidden></div>
      <div id="error-C" class="error" style="display: none;"></div>
      <div id="results-C"></div>
      <div id="pager-C" class="results-pager" hidden></div>
    </section>

    <section class="sleeve-panel" id="panel-D">
      <h3>
        <span class="sleeve-header-name">Supply Chains & Ecosystems</span>
        <span class="sleeve-header-code">Career Sleeve D</span>
      </h3>
      <div class="terms-editor" data-sleeve="D">
        <label class="terms-label" for="terms-input-D">Search terms</label>
        <div id="terms-chips-D" class="terms-chip-list" aria-live="polite"></div>
        <input id="terms-input-D" class="terms-input" type="text" placeholder="Type term and press Enter">
        <div class="terms-actions">
          <button type="button" class="terms-reset-btn" onclick="resetSleeveTerms('D')">Reset terms</button>
        </div>
      </div>
      <button type="button" class="scrape-btn" data-sleeve="D" onclick="startScraping('D')">Scrape Career Sleeve D</button>
      <p id="status-D" aria-live="polite"></p>
      <div id="progress-D" class="progress-field" hidden></div>
      <div id="summary-D" class="sleeve-summary" hidden></div>
      <div id="error-D" class="error" style="display: none;"></div>
      <div id="results-D"></div>
      <div id="pager-D" class="results-pager" hidden></div>
    </section>

    <section class="sleeve-panel" id="panel-E">
      <h3>
        <span class="sleeve-header-name">Custom / User-defined Sleeve</span>
        <span class="sleeve-header-code">Career Sleeve E</span>
      </h3>
      <div class="terms-editor" data-sleeve="E">
        <label class="terms-label" for="terms-input-E">Search terms</label>
        <div id="terms-chips-E" class="terms-chip-list" aria-live="polite"></div>
        <input id="terms-input-E" class="terms-input" type="text" placeholder="Type term and press Enter">
        <div class="terms-actions">
          <button type="button" class="terms-reset-btn" onclick="resetSleeveTerms('E')">Reset terms</button>
        </div>
      </div>
      <button type="button" class="scrape-btn" data-sleeve="E" onclick="startScraping('E')">Scrape Career Sleeve E</button>
      <p id="status-E" aria-live="polite"></p>
      <div id="progress-E" class="progress-field" hidden></div>
      <div id="summary-E" class="sleeve-summary" hidden></div>
      <div id="error-E" class="error" style="display: none;"></div>
      <div id="results-E"></div>
      <div id="pager-E" class="results-pager" hidden></div>
    </section>
  </div>

  <script>
    const sleeveKeys = ['A', 'B', 'C', 'D', 'E'];
    const RESULTS_PER_PAGE = 10;
    const DEFAULT_FETCH_LIMIT = 200;
    const TERMS_STORAGE_PREFIX = 'existence.sleeve_terms.v2.';
    const sleeveControllers = {};
    const sleeveProgressPollers = {};
    const sourceHealthTimers = {};
    const sleeveTermState = {};
    let activeScrapeSleeve = '';
    const fallbackConfig = {
      profile: 'mvp',
      sources: [
        { id: 'indeed_web', label: 'Indeed (direct scraping)', available: true, default_enabled: true, reason: '' },
        { id: 'linkedin_web', label: 'LinkedIn (direct scraping)', available: true, default_enabled: true, reason: '' },
      ],
      sleeve_terms_defaults: {
        A: [
          'music event operations',
          'festival producer',
          'tour',
          'concert production',
          'live production',
          'artist liaison',
          'show operations',
          'event operations'
        ],
        B: [
          'theme park operations',
          'attractions operations',
          'guest experience',
          'show operations',
          'ride operations',
          'destination operations',
          'resort operations',
          'immersive destination operations'
        ],
        C: [
          'data center operations',
          'critical facilities technician',
          'facility operations',
          'commissioning engineer data center',
          'mission critical operations',
          'compute infrastructure operations',
          'ai infrastructure operations',
          'capacity expansion data center'
        ],
        D: [
          'supply chain operations',
          'logistics operations',
          'vendor operations',
          'partner operations',
          'ecosystem operations',
          'rollout',
          'implementation supply chain',
          'distribution operations'
        ],
        E: [
          // Intentionally empty: fully user-defined sleeve.
        ]
      },
      defaults: {
        sources: ['indeed_web', 'linkedin_web'],
        location_mode: 'nl_only',
        strict: false,
        max_results: DEFAULT_FETCH_LIMIT,
        failover: false,
        use_cache: true
      },
      location_modes: [
        { id: 'nl_only', label: 'Netherlands focus' },
      ],
    };
    let scrapeConfig = fallbackConfig;
    const sleevePagination = Object.fromEntries(
      sleeveKeys.map((key) => [key, { jobs: [], page: 1 }])
    );

    function sourceLabelMap() {
      const mapping = {};
      (scrapeConfig.sources || []).forEach(source => {
        mapping[source.id] = source.label;
      });
      return mapping;
    }

    function normalizeTermToken(value) {
      return String(value || '').trim().toLowerCase();
    }

    function dedupeTerms(terms) {
      const ordered = [];
      const seen = new Set();
      (terms || []).forEach(term => {
        const cleaned = String(term || '').trim();
        if (cleaned.length < 2) {
          return;
        }
        const normalized = normalizeTermToken(cleaned);
        if (!normalized || seen.has(normalized)) {
          return;
        }
        seen.add(normalized);
        ordered.push(cleaned);
      });
      return ordered;
    }

    function termStorageKey(sleeveKey) {
      return `${TERMS_STORAGE_PREFIX}${sleeveKey}`;
    }

    function getDefaultTermsForSleeve(sleeveKey) {
      const defaults = scrapeConfig.sleeve_terms_defaults || {};
      return dedupeTerms(Array.isArray(defaults[sleeveKey]) ? defaults[sleeveKey] : []);
    }

    function loadPersistedSleeveTerms(sleeveKey) {
      const defaults = getDefaultTermsForSleeve(sleeveKey);
      try {
        const stored = localStorage.getItem(termStorageKey(sleeveKey));
        if (!stored) {
          return defaults;
        }
        const parsed = JSON.parse(stored);
        if (!Array.isArray(parsed)) {
          return defaults;
        }
        const merged = dedupeTerms(parsed);
        return merged.length ? merged : defaults;
      } catch (_error) {
        return defaults;
      }
    }

    function persistSleeveTerms(sleeveKey) {
      try {
        localStorage.setItem(termStorageKey(sleeveKey), JSON.stringify(sleeveTermState[sleeveKey] || []));
      } catch (_error) {
      }
    }

    function removeSleeveTerm(sleeveKey, index) {
      const current = Array.isArray(sleeveTermState[sleeveKey]) ? sleeveTermState[sleeveKey] : [];
      if (index < 0 || index >= current.length) {
        return;
      }
      current.splice(index, 1);
      sleeveTermState[sleeveKey] = current;
      persistSleeveTerms(sleeveKey);
      renderSleeveTerms(sleeveKey);
    }

    function renderSleeveTerms(sleeveKey) {
      const chipsWrap = document.getElementById(`terms-chips-${sleeveKey}`);
      if (!chipsWrap) {
        return;
      }
      const terms = Array.isArray(sleeveTermState[sleeveKey]) ? sleeveTermState[sleeveKey] : [];
      chipsWrap.innerHTML = '';

      if (!terms.length) {
        const empty = document.createElement('span');
        empty.className = 'term-chip-empty';
        empty.textContent = 'No terms configured. Add at least one term.';
        chipsWrap.appendChild(empty);
        return;
      }

      terms.forEach((term, index) => {
        const chip = document.createElement('span');
        chip.className = 'term-chip';

        const label = document.createElement('span');
        label.className = 'term-chip-label';
        label.textContent = term;
        chip.appendChild(label);

        const remove = document.createElement('button');
        remove.type = 'button';
        remove.className = 'term-chip-remove';
        remove.textContent = 'x';
        remove.setAttribute('aria-label', `Remove term ${term}`);
        remove.title = 'Remove term';
        remove.addEventListener('click', () => removeSleeveTerm(sleeveKey, index));
        chip.appendChild(remove);

        chipsWrap.appendChild(chip);
      });
    }

    function addSleeveTermsFromInput(sleeveKey) {
      const input = document.getElementById(`terms-input-${sleeveKey}`);
      if (!input) {
        return;
      }
      const raw = String(input.value || '').trim();
      if (!raw) {
        return;
      }
      const chunks = raw.split(/[,;\n\r|]+/).map(part => part.trim()).filter(Boolean);
      if (!chunks.length) {
        input.value = '';
        return;
      }
      const current = Array.isArray(sleeveTermState[sleeveKey]) ? sleeveTermState[sleeveKey] : [];
      sleeveTermState[sleeveKey] = dedupeTerms(current.concat(chunks));
      input.value = '';
      persistSleeveTerms(sleeveKey);
      renderSleeveTerms(sleeveKey);
    }

    function resetSleeveTerms(sleeveKey) {
      sleeveTermState[sleeveKey] = getDefaultTermsForSleeve(sleeveKey);
      persistSleeveTerms(sleeveKey);
      renderSleeveTerms(sleeveKey);
    }

    function initializeTermEditors() {
      sleeveKeys.forEach((sleeveKey) => {
        const input = document.getElementById(`terms-input-${sleeveKey}`);
        if (!input) {
          return;
        }
        if (!input.dataset.bound) {
          input.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              addSleeveTermsFromInput(sleeveKey);
            }
          });
          input.dataset.bound = '1';
        }
        sleeveTermState[sleeveKey] = loadPersistedSleeveTerms(sleeveKey);
        renderSleeveTerms(sleeveKey);
      });
    }

    function resolveWorkMode(job) {
      const explicit = String(job.work_mode || '').trim();
      if (explicit) {
        return explicit;
      }
      const text = `${job.location || ''} ${job.snippet || ''} ${job.full_description || ''}`.toLowerCase();
      if (text.includes('hybrid') || text.includes('hybride')) {
        return 'Hybrid';
      }
      if (
        text.includes('remote') ||
        text.includes('op afstand') ||
        text.includes('thuiswerk') ||
        text.includes('werk vanuit huis')
      ) {
        return 'Remote';
      }
      if (
        text.includes('on-site') ||
        text.includes('onsite') ||
        text.includes('on site') ||
        text.includes('op locatie') ||
        text.includes('op kantoor')
      ) {
        return 'On-site';
      }
      return 'Unknown';
    }

    function setScrapeButtonsLocked(activeSleeve) {
      const scrapeButtons = document.querySelectorAll('.scrape-btn[data-sleeve]');
      scrapeButtons.forEach((button) => {
        const sleeve = button.getAttribute('data-sleeve') || '';
        const shouldDisable = Boolean(activeSleeve) && sleeve !== activeSleeve;
        button.disabled = shouldDisable;
        button.classList.toggle('scrape-btn-disabled', shouldDisable);
      });
    }

    function createBadge(className, text) {
      const badge = document.createElement('span');
      badge.className = className;
      badge.textContent = text;
      return badge;
    }

    function isValidHttpUrl(url) {
      const value = String(url || '').trim();
      return /^https?:\/\//i.test(value);
    }

    function isIndeedUrl(url) {
      if (!isValidHttpUrl(url)) {
        return false;
      }
      try {
        return new URL(url).hostname.toLowerCase().includes('indeed.');
      } catch (error) {
        return false;
      }
    }

    function isLinkedInUrl(url) {
      if (!isValidHttpUrl(url)) {
        return false;
      }
      try {
        const host = new URL(url).hostname.toLowerCase();
        return host.includes('linkedin.com') || host.endsWith('lnkd.in');
      } catch (error) {
        return false;
      }
    }

    function isPlatformUrl(url) {
      return isIndeedUrl(url) || isLinkedInUrl(url);
    }

    function safeDecodeUrlPart(value) {
      let decoded = String(value || '');
      for (let i = 0; i < 2; i += 1) {
        try {
          const next = decodeURIComponent(decoded);
          if (next === decoded) {
            break;
          }
          decoded = next;
        } catch (error) {
          break;
        }
      }
      return decoded;
    }

    function extractExternalFromPlatformUrl(url) {
      if (!isValidHttpUrl(url)) {
        return '';
      }
      try {
        const parsed = new URL(url);
        const redirectKeys = ['adurl', 'dest', 'destination', 'redirect', 'redirecturl', 'url', 'u', 'target'];
        for (const key of redirectKeys) {
          const raw = parsed.searchParams.get(key);
          if (!raw) {
            continue;
          }
          const decoded = safeDecodeUrlPart(raw);
          if (!isValidHttpUrl(decoded)) {
            continue;
          }
          const host = new URL(decoded).hostname.toLowerCase();
          if (!host.includes('indeed.') && !host.includes('linkedin.com') && !host.endsWith('lnkd.in')) {
            return decoded;
          }
        }
      } catch (error) {
        return '';
      }
      return '';
    }

    function buildCompanyResolverUrl(companyUrl, indeedUrl, linkedinUrl, jobUrl) {
      const params = new URLSearchParams();
      if (isValidHttpUrl(companyUrl)) {
        params.set('company_url', companyUrl);
      }
      if (isValidHttpUrl(indeedUrl)) {
        params.set('indeed_url', indeedUrl);
      }
      if (isValidHttpUrl(linkedinUrl)) {
        params.set('linkedin_url', linkedinUrl);
      }
      if (isValidHttpUrl(jobUrl)) {
        params.set('job_url', jobUrl);
      }
      const qs = params.toString();
      if (!qs) {
        return '';
      }
      return `/company-posting?${qs}`;
    }

    function createActionLink(label, href, extraClass = '', enabled = true) {
      const link = document.createElement('a');
      link.className = `job-link-btn ${extraClass}`.trim();
      link.href = enabled ? href : '#';
      link.textContent = label;
      if (enabled) {
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
      } else {
        link.classList.add('job-link-disabled');
        link.setAttribute('aria-disabled', 'true');
        link.tabIndex = -1;
      }
      return link;
    }

    function toMetricValue(value, fallback = '-') {
      const numeric = Number(value);
      if (Number.isFinite(numeric)) {
        return String(numeric);
      }
      return fallback;
    }

    function buildMetricsMarkup(summary, fallbackRaw = 0) {
      const hasSummary = Boolean(summary && typeof summary === 'object');
      const rawValue = hasSummary ? toMetricValue(summary.raw_count, '0') : toMetricValue(fallbackRaw, '0');
      const dedupedValue = hasSummary ? toMetricValue(summary.deduped_count, '-') : '-';
      const passValue = hasSummary ? toMetricValue(summary.pass_count, '-') : '-';
      const maybeValue = hasSummary ? toMetricValue(summary.maybe_count, '-') : '-';
      const failValue = hasSummary ? toMetricValue(summary.fail_count, '-') : '-';
      return `
        <div class="summary-metrics progress-metrics">
          <span class="metric-badge">RAW ${rawValue}</span>
          <span class="metric-badge">DEDUPED ${dedupedValue}</span>
          <span class="metric-badge metric-pass">PASS ${passValue}</span>
          <span class="metric-badge metric-maybe">MAYBE ${maybeValue}</span>
          <span class="metric-badge metric-fail">FAIL ${failValue}</span>
        </div>
      `;
    }

    function renderSleeveSummary(sleeveKey, summary, sourcesText) {
      const summaryWrap = document.getElementById(`summary-${sleeveKey}`);
      summaryWrap.innerHTML = '';
      summaryWrap.hidden = true;
      const progressDiv = document.getElementById(`progress-${sleeveKey}`);
      if (!progressDiv || !summary) {
        return;
      }
      let metricsWrap = progressDiv.querySelector('.progress-metrics');
      if (!metricsWrap) {
        progressDiv.insertAdjacentHTML('beforeend', buildMetricsMarkup(summary, 0));
      } else {
        metricsWrap.outerHTML = buildMetricsMarkup(summary, 0);
      }
    }

    function clearSleevePager(sleeveKey) {
      sleevePagination[sleeveKey] = { jobs: [], page: 1 };
      const pagerDiv = document.getElementById(`pager-${sleeveKey}`);
      if (!pagerDiv) {
        return;
      }
      pagerDiv.innerHTML = '';
      pagerDiv.hidden = true;
    }

    function stopProgressPolling(sleeveKey) {
      const active = sleeveProgressPollers[sleeveKey];
      if (active) {
        clearInterval(active);
        delete sleeveProgressPollers[sleeveKey];
      }
    }

    function stopSourceHealthTimer(sleeveKey) {
      const active = sourceHealthTimers[sleeveKey];
      if (active) {
        clearInterval(active);
        delete sourceHealthTimers[sleeveKey];
      }
    }

    function formatCooldownSeconds(seconds) {
      const value = Math.max(0, Number(seconds || 0));
      if (!Number.isFinite(value)) {
        return '0s';
      }
      const total = Math.floor(value);
      const mins = Math.floor(total / 60);
      const secs = total % 60;
      if (mins > 0) {
        return `${mins}m ${secs}s`;
      }
      return `${secs}s`;
    }

    function formatProgressTime(value) {
      const ts = Number(value || 0);
      if (!Number.isFinite(ts) || ts <= 0) {
        return '';
      }
      const date = new Date(ts * 1000);
      if (Number.isNaN(date.getTime())) {
        return '';
      }
      return date.toLocaleTimeString([], { hour12: false });
    }

    function renderProgress(sleeveKey, payload) {
      const progressDiv = document.getElementById(`progress-${sleeveKey}`);
      if (!progressDiv) {
        return;
      }
      const status = String(payload?.status || 'running').toUpperCase();
      const updated = formatProgressTime(payload?.updated_at);
      const summary = payload?.summary && typeof payload.summary === 'object'
        ? payload.summary
        : null;
      const events = Array.isArray(payload?.events) ? payload.events : [];
      const latest = events[events.length - 1];
      const recent = events.slice(-7);
      const runningRaw = events
        .filter(event => String(event?.step || '').toLowerCase() === 'source-finish')
        .reduce((total, event) => total + Number(event?.item_count || 0), 0);
      const listItems = recent
        .map(event => `<li>${event?.message || ''}</li>`)
        .join('');
      progressDiv.innerHTML = `
        <div class="progress-status">
          ${status}${updated ? ` â€¢ ${updated}` : ''}
        </div>
        ${buildMetricsMarkup(summary, runningRaw)}
        ${latest?.message ? `<div class="progress-latest">${latest.message}</div>` : ''}
        ${recent.length ? `<ul class="progress-list">${listItems}</ul>` : ''}
      `;
      progressDiv.hidden = false;
    }

    function setProgressOutcome(sleeveKey, title, lines = [], tone = 'info', summary = null) {
      const progressDiv = document.getElementById(`progress-${sleeveKey}`);
      if (!progressDiv) {
        return;
      }
      let metricsWrap = progressDiv.querySelector('.progress-metrics');
      if (summary) {
        if (!metricsWrap) {
          progressDiv.insertAdjacentHTML('beforeend', buildMetricsMarkup(summary, 0));
        } else {
          metricsWrap.outerHTML = buildMetricsMarkup(summary, 0);
        }
      }
      let outcome = progressDiv.querySelector('.progress-outcome');
      if (!outcome) {
        outcome = document.createElement('div');
        progressDiv.appendChild(outcome);
      }
      outcome.className = `progress-outcome progress-outcome-${tone}`;
      outcome.innerHTML = '';

      const heading = document.createElement('div');
      heading.className = 'progress-outcome-title';
      heading.textContent = title;
      outcome.appendChild(heading);

      const safeLines = Array.isArray(lines)
        ? lines.map(line => String(line || '').trim()).filter(Boolean)
        : [];
      if (safeLines.length) {
        const list = document.createElement('ul');
        list.className = 'progress-outcome-list';
        safeLines.forEach(line => {
          const item = document.createElement('li');
          item.textContent = line;
          list.appendChild(item);
        });
        outcome.appendChild(list);
      }

      progressDiv.hidden = false;
      progressDiv.scrollTop = progressDiv.scrollHeight;
    }

    function renderSourceHealthInProgress(sleeveKey, sourceHealth, onRetry) {
      stopSourceHealthTimer(sleeveKey);
      const progressDiv = document.getElementById(`progress-${sleeveKey}`);
      if (!progressDiv) {
        return;
      }
      const healthEntries = sourceHealth && typeof sourceHealth === 'object'
        ? Object.entries(sourceHealth)
        : [];
      if (!healthEntries.length) {
        return;
      }

      let wrap = progressDiv.querySelector('.progress-source-health');
      if (!wrap) {
        wrap = document.createElement('div');
        wrap.className = 'progress-source-health';
        progressDiv.appendChild(wrap);
      }
      wrap.innerHTML = '';

      healthEntries.forEach(([sourceId, health]) => {
        const state = String(health?.state || 'ok').toLowerCase();
        const label = sourceLabelMap()[sourceId] || sourceId;
        const stateRow = document.createElement('div');
        stateRow.className = `progress-source-state progress-source-state-${state}`;
        stateRow.textContent = `${label}: ${state.toUpperCase()}`;
        wrap.appendChild(stateRow);

        const lastError = String(health?.last_error || '').trim();
        if (lastError) {
          const errorRow = document.createElement('div');
          errorRow.className = 'progress-source-error';
          errorRow.textContent = `Last error: ${lastError}`;
          wrap.appendChild(errorRow);
        }

        const nextRetryAt = Number(health?.next_retry_at || 0);
        const cooldownFromApi = Number(health?.cooldown_seconds_remaining || 0);
        const hasCooldown = nextRetryAt > 0 || cooldownFromApi > 0;
        if (!hasCooldown) {
          return;
        }

        const cooldownRow = document.createElement('div');
        cooldownRow.className = 'progress-source-cooldown';
        const cooldownLabel = document.createElement('span');
        cooldownLabel.className = 'progress-source-cooldown-label';
        cooldownLabel.textContent = 'Cooldown remaining:';
        const cooldownValue = document.createElement('strong');
        cooldownValue.className = 'progress-source-cooldown-value';
        cooldownRow.appendChild(cooldownLabel);
        cooldownRow.appendChild(cooldownValue);
        wrap.appendChild(cooldownRow);

        const retryBtn = document.createElement('button');
        retryBtn.type = 'button';
        retryBtn.className = 'progress-retry-btn';
        retryBtn.textContent = 'Retry source';
        retryBtn.addEventListener('click', () => {
          if (typeof onRetry === 'function') {
            onRetry();
          }
        });
        wrap.appendChild(retryBtn);

        const updateCooldown = () => {
          const now = Math.floor(Date.now() / 1000);
          const byNextRetry = nextRetryAt > 0 ? Math.max(0, nextRetryAt - now) : 0;
          const remaining = byNextRetry || Math.max(0, Math.floor(cooldownFromApi));
          cooldownValue.textContent = formatCooldownSeconds(remaining);
          retryBtn.disabled = remaining > 0;
          retryBtn.textContent = remaining > 0
            ? `Retry source in ${formatCooldownSeconds(remaining)}`
            : 'Retry source now';
          if (remaining <= 0) {
            stopSourceHealthTimer(sleeveKey);
          }
        };

        updateCooldown();
        if (nextRetryAt > 0) {
          sourceHealthTimers[sleeveKey] = setInterval(updateCooldown, 1000);
        }
      });

      progressDiv.hidden = false;
      progressDiv.scrollTop = progressDiv.scrollHeight;
    }

    function startProgressPolling(sleeveKey, runId) {
      stopProgressPolling(sleeveKey);
      const progressDiv = document.getElementById(`progress-${sleeveKey}`);
      if (progressDiv) {
        progressDiv.hidden = false;
        progressDiv.innerHTML = '<div class="progress-status">STARTING</div><div class="progress-latest">Initializing scrape...</div>';
      }

      const fetchProgress = () => {
        fetch(`/scrape-progress/${encodeURIComponent(runId)}?tail=30`, { cache: 'no-store' })
          .then(response => {
            if (!response.ok) {
              return null;
            }
            return response.json();
          })
          .then(payload => {
            if (!payload) {
              return;
            }
            renderProgress(sleeveKey, payload);
            const state = String(payload.status || '').toLowerCase();
            if (state === 'done' || state === 'error') {
              stopProgressPolling(sleeveKey);
            }
          })
          .catch(() => {});
      };

      fetchProgress();
      sleeveProgressPollers[sleeveKey] = setInterval(fetchProgress, 1000);
    }

    function renderSleevePage(sleeveKey, requestedPage = 1) {
      const resultsDiv = document.getElementById(`results-${sleeveKey}`);
      const pagerDiv = document.getElementById(`pager-${sleeveKey}`);
      const state = sleevePagination[sleeveKey] || { jobs: [], page: 1 };
      const jobs = Array.isArray(state.jobs) ? state.jobs : [];

      resultsDiv.innerHTML = '';
      pagerDiv.innerHTML = '';

      if (!jobs.length) {
        pagerDiv.hidden = true;
        return;
      }

      const total = jobs.length;
      const pageCount = Math.max(1, Math.ceil(total / RESULTS_PER_PAGE));
      const safePage = Math.min(Math.max(1, requestedPage), pageCount);
      const startIndex = (safePage - 1) * RESULTS_PER_PAGE;
      const endIndex = Math.min(startIndex + RESULTS_PER_PAGE, total);

      sleevePagination[sleeveKey] = { jobs, page: safePage };
      jobs.slice(startIndex, endIndex).forEach(job => {
        resultsDiv.appendChild(createJobResult(job));
      });

      const prevBtn = document.createElement('button');
      prevBtn.type = 'button';
      prevBtn.className = 'pager-btn';
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = safePage <= 1;
      prevBtn.addEventListener('click', () => renderSleevePage(sleeveKey, safePage - 1));

      const nextBtn = document.createElement('button');
      nextBtn.type = 'button';
      nextBtn.className = 'pager-btn';
      nextBtn.textContent = 'Next';
      nextBtn.disabled = safePage >= pageCount;
      nextBtn.addEventListener('click', () => renderSleevePage(sleeveKey, safePage + 1));

      const info = document.createElement('span');
      info.className = 'pager-info';
      info.textContent = `Showing ${startIndex + 1}-${endIndex} of ${total} (page ${safePage}/${pageCount})`;

      pagerDiv.appendChild(prevBtn);
      pagerDiv.appendChild(info);
      pagerDiv.appendChild(nextBtn);
      pagerDiv.hidden = false;
    }

    function createJobResult(job) {
      const card = document.createElement('article');
      card.className = 'job-card';

      const sourceLabels = sourceLabelMap();
      const decision = (job.decision || 'PASS').toUpperCase();
      const sleeveId = job.primary_sleeve_id || job.primary_sleeve || '-';
      const mode = resolveWorkMode(job);
      const abroadScore = Number.isFinite(job.abroad_score) ? Number(job.abroad_score) : 0;
      const abroadPctText = String(job.abroad_percentage_text || '').trim();
      const abroadShare = abroadPctText || (Number.isFinite(job.abroad_percentage) ? `${job.abroad_percentage}%` : '');
      const abroadLocations = Array.isArray(job.abroad_locations) ? job.abroad_locations : [];
      const mainLocation = String(job.main_location || job.location || 'Unknown').trim() || 'Unknown';
      const distanceKm = Number.isFinite(job.distance_from_home_km) ? Number(job.distance_from_home_km) : null;
      const distanceAnchor = String(job.distance_anchor || 'Home').trim() || 'Home';
      const proximityScore = Number.isFinite(job.proximity_score) ? Number(job.proximity_score) : null;
      const primaryLink = isValidHttpUrl(job.link || job.url) ? (job.link || job.url) : '';
      const canonicalIndeedUrl = isValidHttpUrl(job.indeed_url)
        ? job.indeed_url
        : (isIndeedUrl(primaryLink) ? primaryLink : '');
      const canonicalLinkedInUrl = isValidHttpUrl(job.linkedin_url)
        ? job.linkedin_url
        : (isLinkedInUrl(primaryLink) ? primaryLink : '');
      const platformIndeedUrl = canonicalIndeedUrl || (isIndeedUrl(primaryLink) ? primaryLink : '');
      const platformLinkedInUrl = canonicalLinkedInUrl || (isLinkedInUrl(primaryLink) ? primaryLink : '');
      let companyUrl = isValidHttpUrl(job.company_url) ? job.company_url : '';
      if (isPlatformUrl(companyUrl)) {
        companyUrl = '';
      }
      if (
        companyUrl
        && (
          (platformIndeedUrl && companyUrl === platformIndeedUrl)
          || (platformLinkedInUrl && companyUrl === platformLinkedInUrl)
        )
      ) {
        companyUrl = '';
      }
      if (!companyUrl) {
        companyUrl = extractExternalFromPlatformUrl(platformIndeedUrl) || extractExternalFromPlatformUrl(platformLinkedInUrl);
      }
      if (companyUrl && isPlatformUrl(companyUrl)) {
        companyUrl = '';
      }
      if (!companyUrl && isValidHttpUrl(primaryLink) && !isPlatformUrl(primaryLink)) {
        companyUrl = primaryLink;
      }
      const companyResolverUrl = buildCompanyResolverUrl(
        companyUrl,
        platformIndeedUrl,
        platformLinkedInUrl,
        primaryLink
      );

      const header = document.createElement('div');
      header.className = 'job-card-header';
      const title = document.createElement('h3');
      title.textContent = job.title || 'Unknown role';
      const company = document.createElement('p');
      company.className = 'job-company';
      company.textContent = job.company || 'Unknown company';
      header.appendChild(title);
      header.appendChild(company);
      card.appendChild(header);

      const badges = document.createElement('div');
      badges.className = 'job-badges';
      const decisionClass = decision === 'PASS'
        ? 'decision-badge decision-pass'
        : (decision === 'MAYBE' ? 'decision-badge decision-maybe' : 'decision-badge decision-fail');
      badges.appendChild(createBadge(decisionClass, decision));
      badges.appendChild(createBadge('decision-badge decision-neutral', `Career Sleeve ${sleeveId} ${job.primary_sleeve_score || 0}/5`));
      badges.appendChild(
        createBadge(
          'decision-badge decision-abroad',
          abroadShare ? `Abroad ${abroadScore}/4 ${abroadShare}` : `Abroad ${abroadScore}/4`
        )
      );
      const locationBadgeText = distanceKm === null
        ? `Main ${mainLocation} | ${distanceAnchor} distance n/a`
        : `Main ${mainLocation} | ${distanceKm} km from ${distanceAnchor}`;
      badges.appendChild(
        createBadge(
          'decision-badge decision-location',
          proximityScore === null
            ? locationBadgeText
            : `${locationBadgeText} | ${proximityScore}/4`
        )
      );
      card.appendChild(badges);

      const primaryMeta = document.createElement('p');
      primaryMeta.textContent = `Location: ${job.location || 'Unknown'} | Mode: ${mode}`;
      card.appendChild(primaryMeta);

      const secondaryMeta = document.createElement('p');
      secondaryMeta.textContent = `Salary: ${job.salary || 'Not listed'} | Date: ${job.date || job.date_posted || 'Unknown'} | Source: ${sourceLabels[job.source] || job.source || 'Unknown'}`;
      card.appendChild(secondaryMeta);

      if (abroadLocations.length) {
        const abroadGeo = document.createElement('p');
        abroadGeo.className = 'job-abroad-geo';
        abroadGeo.textContent = `Abroad geo mentions: ${abroadLocations.slice(0, 6).join(', ')}`;
        card.appendChild(abroadGeo);
      }

      const reasons = Array.isArray(job.reasons) && job.reasons.length
        ? job.reasons
        : (Array.isArray(job.why_relevant) ? job.why_relevant : []);
      if (reasons.length) {
        const whyList = document.createElement('ul');
        reasons.slice(0, 2).forEach(reason => {
          const li = document.createElement('li');
          li.textContent = reason;
          whyList.appendChild(li);
        });
        card.appendChild(whyList);
      }

      const actions = document.createElement('div');
      actions.className = 'job-actions';
      actions.appendChild(
        createActionLink(
          'Company URL',
          companyResolverUrl || '#',
          'job-link-company',
          Boolean(companyResolverUrl)
        )
      );
      if (platformIndeedUrl) {
        actions.appendChild(
          createActionLink(
            'Indeed URL',
            platformIndeedUrl,
            'job-link-indeed',
            true
          )
        );
      }
      if (platformLinkedInUrl) {
        actions.appendChild(
          createActionLink(
            'LinkedIn URL',
            platformLinkedInUrl,
            'job-link-linkedin',
            true
          )
        );
      }
      card.appendChild(actions);

      return card;
    }

    async function loadScrapeConfig() {
      try {
        const response = await fetch('/scrape-config');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = await response.json();
        if (payload && Array.isArray(payload.sources) && payload.defaults) {
          scrapeConfig = payload;
        }
      } catch (error) {
        scrapeConfig = fallbackConfig;
      } finally {
        renderControls();
      }
    }

    function renderControls() {
      const defaults = scrapeConfig.defaults || fallbackConfig.defaults;
      const profile = String(scrapeConfig.profile || 'mvp').toLowerCase();
      const locationModes = scrapeConfig.location_modes || [
        { id: 'nl_only', label: 'Netherlands focus' },
        { id: 'nl_eu', label: 'Netherlands + EU remote' },
        { id: 'global', label: 'Global' }
      ];
      const profileHint = document.getElementById('profile-hint');
      profileHint.textContent = profile === 'mvp'
        ? 'Active profile: MVP (Indeed + LinkedIn direct sources, NL focus).'
        : `Active profile: ${profile.toUpperCase()}.`;

      const locationSelect = document.getElementById('global-location');
      locationSelect.innerHTML = '';
      locationModes.forEach(mode => {
        const option = document.createElement('option');
        option.value = mode.id;
        option.textContent = mode.label;
        locationSelect.appendChild(option);
      });
      locationSelect.value = defaults.location_mode || 'nl_only';
      document.getElementById('global-strict').checked = defaults.strict !== false;
      document.getElementById('global-cache').checked = defaults.use_cache !== false;
      const failoverInput = document.getElementById('global-failover');
      const failoverWrap = document.getElementById('global-failover-wrap');
      failoverInput.checked = defaults.failover === true;
      failoverInput.disabled = profile === 'mvp';
      failoverWrap.style.opacity = profile === 'mvp' ? '0.55' : '1';

      const sourceWrap = document.getElementById('global-sources');
      const unavailableWrapper = document.getElementById('unavailable-sources');
      const unavailableList = document.getElementById('unavailable-source-list');
      sourceWrap.innerHTML = '';
      unavailableList.innerHTML = '';

      const availableSources = (scrapeConfig.sources || []).filter(source => source.available);
      const unavailableSources = (scrapeConfig.sources || []).filter(source => !source.available);
      availableSources.forEach(source => {
        const checkedByDefault = (defaults.sources || []).includes(source.id) || availableSources.length === 1;
        const sourceState = String(source.state || 'ok').toLowerCase();
        const sourceCooldown = Number(source.cooldown_seconds_remaining || 0);
        const sourceStateText = sourceState === 'ok'
          ? 'OK'
          : `${sourceState.toUpperCase()}${sourceCooldown > 0 ? ` (${formatCooldownSeconds(sourceCooldown)})` : ''}`;
        const label = document.createElement('label');
        label.className = 'source-option source-pill';
        label.innerHTML = `
          <input type="checkbox" data-source-id="${source.id}" ${checkedByDefault ? 'checked' : ''} ${profile === 'mvp' ? 'disabled' : ''}>
          ${source.label} - ${sourceStateText}
        `;
        sourceWrap.appendChild(label);
      });

      if (profile !== 'mvp' && unavailableSources.length) {
        unavailableWrapper.hidden = false;
        unavailableSources.forEach(source => {
          const row = document.createElement('div');
          row.className = 'unavailable-row';
          row.textContent = `${source.label} - ${source.reason || 'Unavailable on this server'}`;
          unavailableList.appendChild(row);
        });
      } else {
        unavailableWrapper.hidden = true;
      }

      const sourceNote = document.getElementById('source-note');
      if (!availableSources.length) {
        sourceNote.textContent = 'No sources are currently available. Check API keys on the server.';
      } else if (profile === 'mvp') {
        sourceNote.textContent = `MVP mode: using direct sources (${availableSources.map(source => source.label).join(', ')}).`;
      } else {
        sourceNote.textContent = `Recommended: ${availableSources
          .filter(source => (defaults.sources || []).includes(source.id))
          .map(source => source.label)
          .join(', ') || availableSources[0].label}`;
      }

      initializeTermEditors();
      setScrapeButtonsLocked(activeScrapeSleeve);
    }

    function selectedSources() {
      const wrap = document.getElementById('global-sources');
      return Array.from(wrap.querySelectorAll('input[type="checkbox"]:checked'))
        .map(input => input.getAttribute('data-source-id'))
        .filter(Boolean);
    }

    function buildScrapeUrl(sleeveKey, runId, options = {}) {
      const allowedSourceIds = ['indeed_web', 'linkedin_web'];
      let sources = selectedSources().filter(sourceId => allowedSourceIds.includes(sourceId));
      if (!sources.length) {
        const defaultSources = Array.isArray(scrapeConfig.defaults?.sources) ? scrapeConfig.defaults.sources : [];
        sources = defaultSources.filter(sourceId => allowedSourceIds.includes(sourceId));
      }
      if (!sources.length) {
        sources = (scrapeConfig.sources || [])
          .filter(source => source.available && allowedSourceIds.includes(source.id))
          .map(source => source.id);
      }
      if (!sources.length) {
        sources = ['indeed_web', 'linkedin_web'];
      }
      const maxResults = Math.max(
        DEFAULT_FETCH_LIMIT,
        Number(scrapeConfig.defaults?.max_results || DEFAULT_FETCH_LIMIT)
      );
      const forceSourceRetry = Boolean(options && options.forceSourceRetry);
      const hasIndeed = sources.includes('indeed_web');
      const hasLinkedIn = sources.includes('linkedin_web');
      const tunedMaxPages = hasIndeed && hasLinkedIn ? 2 : (hasIndeed ? 1 : 3);
      const tunedTargetRaw = hasIndeed && hasLinkedIn
        ? Math.max(50, Math.min(150, maxResults * 3))
        : (hasIndeed
          ? Math.max(30, Math.min(90, maxResults * 2))
          : Math.max(40, Math.min(120, maxResults * 3)));
      const queryTerms = dedupeTerms(sleeveTermState[sleeveKey] || getDefaultTermsForSleeve(sleeveKey));
      if (!queryTerms.length) {
        setProgressOutcome(
          sleeveKey,
          'INPUT REQUIRED',
          [`Add at least one search term before scraping Career Sleeve ${sleeveKey}.`],
          'warn'
        );
        return '';
      }
      const params = new URLSearchParams();
      params.set('sleeve', sleeveKey);
      params.set('location_mode', 'nl_only');
      params.set('strict', '0');
      params.set('max_results', String(maxResults));
      params.set('max_pages', String(tunedMaxPages));
      params.set('target_raw', String(tunedTargetRaw));
      params.set('rps', '0.35');
      params.set('detail_rps', '0.20');
      params.set('no_new_unique_pages', hasIndeed && !hasLinkedIn ? '1' : '2');
      params.set('refresh', forceSourceRetry ? '1' : '0');
      params.set('retry_source', forceSourceRetry ? '1' : '0');
      params.set('failover', '0');
      params.set('sources', sources.join(','));
      params.set('run_id', String(runId || ''));
      if (queryTerms.length) {
        params.set('query_terms', queryTerms.join(','));
      }
      return `/scrape?${params.toString()}`;
    }

    function startScraping(sleeveKey, options = {}) {
      const resultsDiv = document.getElementById(`results-${sleeveKey}`);
      const status = document.getElementById(`status-${sleeveKey}`);
      const summaryDiv = document.getElementById(`summary-${sleeveKey}`);
      const panel = document.getElementById(`panel-${sleeveKey}`);
      const runId = `${sleeveKey}-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`;
      addSleeveTermsFromInput(sleeveKey);

      if (activeScrapeSleeve && activeScrapeSleeve !== sleeveKey) {
        setProgressOutcome(
          sleeveKey,
          'SCRAPE LOCKED',
          [`Wait until Career Sleeve ${activeScrapeSleeve} is finished. We run one scrape at a time to reduce blocking.`],
          'warn'
        );
        return;
      }
      const scrapeUrl = buildScrapeUrl(sleeveKey, runId, options);
      if (!scrapeUrl) {
        return;
      }

      if (sleeveControllers[sleeveKey]) {
        sleeveControllers[sleeveKey].abort();
      }
      const controller = new AbortController();
      sleeveControllers[sleeveKey] = controller;
      const timeoutId = setTimeout(() => controller.abort(), 120000);
      activeScrapeSleeve = sleeveKey;
      setScrapeButtonsLocked(activeScrapeSleeve);

      panel.classList.add('loading');
      resultsDiv.innerHTML = '';
      summaryDiv.innerHTML = '';
      summaryDiv.hidden = true;
      clearSleevePager(sleeveKey);
      stopProgressPolling(sleeveKey);
      stopSourceHealthTimer(sleeveKey);
      startProgressPolling(sleeveKey, runId);
      status.textContent = '';

      fetch(scrapeUrl, { signal: controller.signal })
        .then(async response => {
          const contentType = (response.headers.get('content-type') || '').toLowerCase();
          const isJson = contentType.includes('application/json');

          if (!response.ok) {
            if (isJson) {
              const payload = await response.json();
              const details = Array.isArray(payload.details) ? payload.details.filter(Boolean) : [];
              const detailsText = details.length ? ` (${details.slice(0, 2).join(' | ')})` : '';
              throw new Error((payload.error || `HTTP ${response.status}`) + detailsText);
            }

            const bodyText = await response.text();
            const compact = bodyText.replace(/\s+/g, ' ').trim().slice(0, 180);
            throw new Error(`HTTP ${response.status}: non-JSON response (${compact || 'empty body'})`);
          }

          if (!isJson) {
            const bodyText = await response.text();
            const compact = bodyText.replace(/\s+/g, ' ').trim().slice(0, 180);
            throw new Error(`Expected JSON but received non-JSON response (${compact || 'empty body'})`);
          }

          const payload = await response.json();
          const jobs = Array.isArray(payload)
            ? payload
            : (Array.isArray(payload.jobs) ? payload.jobs : []);
          const summary = (!Array.isArray(payload) && payload.summary && typeof payload.summary === 'object')
            ? payload.summary
            : null;
          const sourcesFromSummary = summary && Array.isArray(summary.sources_used_labels)
            ? summary.sources_used_labels.join(', ')
            : (summary && Array.isArray(summary.sources_used)
              ? summary.sources_used.join(', ')
              : '');
          const profileFromSummary = summary && typeof summary.profile === 'string'
            ? summary.profile
            : '';
          return {
            jobs,
            summary,
            profile: profileFromSummary || (scrapeConfig.profile || 'mvp'),
            sourcesUsed: sourcesFromSummary || response.headers.get('x-sources-used') || 'none'
          };
        })
        .then(payload => {
          const data = payload.jobs;
          const profileText = String(payload.profile || '').toUpperCase();
          const finalTitle = `Finished Career Sleeve ${sleeveKey}${profileText ? ` (${profileText})` : ''}.`;
          const progressLines = [];

          if (payload.summary) {
            renderSleeveSummary(sleeveKey, payload.summary, payload.sourcesUsed);
            if (payload.sourcesUsed) {
              progressLines.push(`Sources used: ${payload.sourcesUsed}`);
            }
            if (Array.isArray(payload.summary.source_errors) && payload.summary.source_errors.length) {
              progressLines.push(`Source diagnostics: ${payload.summary.source_errors.slice(0, 2).join(' | ')}`);
            } else if (Array.isArray(payload.summary.top_fail_reasons) && payload.summary.top_fail_reasons.length) {
              const topReason = payload.summary.top_fail_reasons[0];
              progressLines.push(`Top fail reason: ${topReason.reason} (${topReason.count})`);
            }
          } else {
            if (payload.sourcesUsed) {
              progressLines.push(`Sources used: ${payload.sourcesUsed}`);
            }
          }

          if (!data.length) {
            clearSleevePager(sleeveKey);
            const sourceErrors = payload.summary && Array.isArray(payload.summary.source_errors)
              ? payload.summary.source_errors.filter(Boolean)
              : [];
            if (sourceErrors.length) {
              const blocked = sourceErrors.some(error => String(error || '').toLowerCase().includes('blocked_detected'));
              if (blocked) {
                progressLines.push('One or more sources are blocking this server IP right now.');
                progressLines.push('Retry later, or configure SCRAPE_HTTP_PROXY / SCRAPE_HTTPS_PROXY on the server.');
              } else {
                progressLines.push('No jobs matched this Career Sleeve with current source diagnostics.');
              }
            } else if (payload.summary && Array.isArray(payload.summary.top_fail_reasons) && payload.summary.top_fail_reasons.length) {
              const firstReason = payload.summary.top_fail_reasons[0];
              progressLines.push(`No jobs matched with current filters.`);
              progressLines.push(`Top fail reason: ${firstReason.reason} (${firstReason.count}).`);
            } else {
              progressLines.push('No jobs matched this Career Sleeve with current filters.');
              progressLines.push('Try broadening terms.');
            }
            resultsDiv.textContent = '';
            setProgressOutcome(
              sleeveKey,
              finalTitle,
              progressLines,
              sourceErrors.length ? 'warn' : 'info',
              payload.summary || null
            );
            if (payload.summary && payload.summary.source_health) {
              renderSourceHealthInProgress(sleeveKey, payload.summary.source_health, () => {
                startScraping(sleeveKey, { forceSourceRetry: true });
              });
            }
            return;
          }

          sleevePagination[sleeveKey] = { jobs: data, page: 1 };
          renderSleevePage(sleeveKey, 1);
          progressLines.unshift(`Returned ${data.length} job result${data.length === 1 ? '' : 's'}.`);
          setProgressOutcome(sleeveKey, finalTitle, progressLines, 'ok', payload.summary || null);
          if (payload.summary && payload.summary.source_health) {
            renderSourceHealthInProgress(sleeveKey, payload.summary.source_health, () => {
              startScraping(sleeveKey, { forceSourceRetry: true });
            });
          }
        })
        .catch(error => {
          status.textContent = '';
          stopProgressPolling(sleeveKey);
          stopSourceHealthTimer(sleeveKey);
          const isTimeout = error.name === 'AbortError';
          const message = isTimeout
            ? `Scrape for Career Sleeve ${sleeveKey} timed out after 120 seconds.`
            : `An error occurred while scraping jobs: ${error.message}`;
          setProgressOutcome(sleeveKey, 'SCRAPE ERROR', [message], 'error');
        })
        .finally(() => {
          clearTimeout(timeoutId);
          panel.classList.remove('loading');
          if (sleeveControllers[sleeveKey] === controller) {
            delete sleeveControllers[sleeveKey];
          }
          if (activeScrapeSleeve === sleeveKey) {
            activeScrapeSleeve = '';
            setScrapeButtonsLocked('');
          }
        });
    }

    document.addEventListener('DOMContentLoaded', loadScrapeConfig);
  </script>

  <script src="{{ url_for('static', filename='script.js') }}"></script>
</body>

</html>
